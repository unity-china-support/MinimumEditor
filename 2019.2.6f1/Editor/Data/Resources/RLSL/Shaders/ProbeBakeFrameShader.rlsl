/*
    The contents of this file are provided under the terms described in the accompanying License.txt file. Use of this file in any way acknowledges acceptance of these terms.
    Copyright(c) 2010 - 2017, Imagination Technologies Limited and / or its affiliated group companies. All rights reserved.
*/

uniform sampler2D PositionsTex;
uniform sampler2D ProbeLightIndicesTexture;
uniform int OutputRayCount;
uniform int PassIdx;
uniform int GIMaxSamples;
uniform int GISamplesPerPass;
uniform int GISamplesSoFar;
uniform int DirectMaxSamples;
uniform int DirectSamplesPerPass;
uniform int DirectSamplesSoFar;
uniform int EnvironmentMaxSamples;
uniform int EnvironmentSamplesPerPass;
uniform int EnvironmentSamplesSoFar;
uniform int IgnoreDirectEnvironment;
uniform int DoDirect;

void setup()
{
    rl_OutputRayCount = OutputRayCount;
}

void ProbeSampling(vec3 pos, int samplesForPass, int samplesSoFar, int scramble)
{
    int sampleIndex = samplesSoFar;
    float weight = 4.0/float(GIMaxSamples);

    // Shift is different per probe, this makes a unique scramble per probe. This is needed to ensure a unique Sobol sequence per sample. This is white noise decorrelation.
    int scramble = GetScreenCoordHash(rl_FrameCoord.xy);
    int base = scramble % IntegratorSamples.numGoldenSamples; // We do this as it is not safe to directly add to a scramble value generated by GetScreenCoordHash as we could then go above INT_MAX and the modulo could return a negative value.
    int dim0_rnd = (base + 0) % IntegratorSamples.numGoldenSamples;
    int dim1_rnd = (base + 1) % IntegratorSamples.numGoldenSamples;
    int dim2_rnd = (base + 2) % IntegratorSamples.numGoldenSamples;
    vec3 cpShift = vec3(IntegratorSamples.goldenSamples[dim0_rnd], IntegratorSamples.goldenSamples[dim1_rnd], IntegratorSamples.goldenSamples[dim2_rnd]);

    for(int i = 0; i < samplesForPass; ++i, ++sampleIndex)
    {
        vec2 rnd = fract(vec2(SobolSample(sampleIndex, 0, 0), SobolSample(sampleIndex, 1, 0)) + cpShift.xy);
        vec3 direction = SphereSample(rnd);

        createRay();
        rl_OutRay.origin           = pos;
        rl_OutRay.direction        = direction;
        rl_OutRay.color            = vec4(0.0); // unused, because we're not shooting against lights
        rl_OutRay.probeDir         = normalize(direction);
        rl_OutRay.defaultPrimitive = GetEnvPrimitive();
        rl_OutRay.renderTarget     = PROBE_BUFFER;
        rl_OutRay.isOutgoing       = true;
        rl_OutRay.sampleIndex      = sampleIndex;
        rl_OutRay.cpShift          = cpShift;
        rl_OutRay.rayClass         = GI_RAY_CLASS;
        rl_OutRay.depth            = 0;
        rl_OutRay.weight           = weight;
        rl_OutRay.occlusionTest    = false;
        rl_OutRay.albedo           = vec3(1.0);
        rl_OutRay.sameOriginCount  = 0;
        rl_OutRay.transmissionDepth= 0;
        rl_OutRay.lightmapMode     = LIGHTMAPMODE_NONDIRECTIONAL; // Not used with probe sampling.
        emitRayWithoutDifferentials();
    }
}

void EnvironmentSampling(vec3 pos, int samplesForPass, int samplesSoFar)
{
    int   sampleIndex = samplesSoFar;
    float weight = 1.0/float(EnvironmentMaxSamples);

    // Shift is different per probe, this makes a unique scramble per probe. This is needed to ensure a unique Sobol sequence per sample. This is white noise decorrelation.
    int  scramble = GetScreenCoordHash(rl_FrameCoord.xy);
    int  base     = scramble   % IntegratorSamples.numGoldenSamples; // We do this as it is not safe to directly add to a scramble value generated by GetScreenCoordHash as we could then go above INT_MAX and the modulo could return a negative value.
    int  dim0_rnd = (base + 0) % IntegratorSamples.numGoldenSamples;
    int  dim1_rnd = (base + 1) % IntegratorSamples.numGoldenSamples;
    int  dim2_rnd = (base + 2) % IntegratorSamples.numGoldenSamples;
    vec3 cpShift  = vec3(IntegratorSamples.goldenSamples[dim0_rnd], IntegratorSamples.goldenSamples[dim1_rnd], IntegratorSamples.goldenSamples[dim2_rnd]);

    if (UseEnvironmentMIS())
    {
        for (int i = 0; i < samplesForPass; ++i, ++sampleIndex)
        {
            vec3 rand = fract(vec3(SobolSample(sampleIndex, 0, 0), SobolSample(sampleIndex, 1, 0), SobolSample(sampleIndex, 2, 0)) + cpShift);
            VolumeSampleEnvironmentMIS(PROBE_BUFFER, pos, vec3(0.0), vec3(1.0), rand, weight, 0, 0, false);
        }
    }
    else
    {
        for (int i = 0; i < samplesForPass; ++i, ++sampleIndex)
        {
            vec2 rand = fract(vec2(SobolSample(sampleIndex, 0, 0), SobolSample(sampleIndex, 1, 0)) + cpShift.xy);
            VolumeSampleEnvironment(PROBE_BUFFER, pos, vec3(0.0), vec3(1.0), rand, weight, 0, 0, false);
        }
    }
}

void main()
{
    vec2  frameCoord  = rl_FrameCoord.xy / rl_FrameSize.xy;

    vec4 posTex = texture2D(PositionsTex, frameCoord);

    if(posTex.w <= 0.0)
        return;

    int scramble = GetScreenCoordHash(rl_FrameCoord.xy);

    if (DoDirect == 0)
    {
        if (GISamplesSoFar < GIMaxSamples)
        {
            int clampedGIsamplesPerPass = min (max(0, GIMaxSamples - GISamplesSoFar), GISamplesPerPass);
            ProbeSampling(posTex.xyz, clampedGIsamplesPerPass, GISamplesSoFar, scramble);
        }

        if (IgnoreDirectEnvironment == 0 && EnvironmentSamplesSoFar < EnvironmentMaxSamples && SampleDirectEnvironment())
        {
            int clampedEnvSamplesPerPass = min(max(0, EnvironmentMaxSamples - EnvironmentSamplesSoFar), EnvironmentSamplesPerPass);
            EnvironmentSampling(posTex.xyz, clampedEnvSamplesPerPass, EnvironmentSamplesSoFar);
        }
    }
    else
    {
        // Direct and probe occlusion are done in the first interation.
        if (DirectSamplesSoFar < DirectMaxSamples)
        {
            int base = scramble % IntegratorSamples.numGoldenSamples; // We do this as it is not safe to directly add to a scramble value generated by GetScreenCoordHash as we could then go above INT_MAX and the modulo could return a negative value.
            int dim0_rnd = (base + 0) % IntegratorSamples.numGoldenSamples;
            int dim1_rnd = (base + 1) % IntegratorSamples.numGoldenSamples;
            vec2 cpShift = vec2(IntegratorSamples.goldenSamples[dim0_rnd], IntegratorSamples.goldenSamples[dim1_rnd]);
            int clampedDirectsamplesPerPass = min (max(0, DirectMaxSamples - DirectSamplesSoFar), DirectSamplesPerPass);

            int sampleIndex = DirectSamplesSoFar;
            for (int i = 0; i < DirectSamplesPerPass; ++i, ++sampleIndex)
            {
                float weight = 1.0/float(DirectMaxSamples);
                vec2 rnd = fract(vec2(SobolSample(sampleIndex, 0, 0), SobolSample(sampleIndex, 1, 0)) + cpShift);

                // Direct
                DoShadows(posTex.xyz, vec3(0.0), vec3(1.0), PROBE_BUFFER, rnd, vec3(0.0), LIGHTMAPMODE_NOTUSED, false, OCCLUSIONMODE_DIRECT, vec4(-1.0), weight, true);

                // Probe Occlusion
                vec4 lightIndices = texture2D(ProbeLightIndicesTexture, frameCoord);
                DoShadows(posTex.xyz, vec3(0.0), vec3(1.0), PROBE_OCCLUSION_BUFFER, rnd, vec3(0.0), LIGHTMAPMODE_NOTUSED, false, OCCLUSIONMODE_PROBEOCCLUSION, lightIndices, weight, true);
            }
        }
    }
}
